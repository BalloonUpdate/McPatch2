### 管理端的所有功能

1. 打包新版本
2. 合并新版本
3. 解压并测试现有的文件
4. 合并版本
5. 检查工作空间目录修改情况
6. 同步线上版本

### 管理端整体架构

1. 数据存储
2. 计算文件差异
3. 更新包格式
4. 版本打包
5. 版本合并
6. 基于TBF的流控

#### 1.数据存储

| 什么东西                  | 什么用途                     |
| ------------------------- | ---------------------------- |
| public                    | 存放更新包和索引文件         |
| workspace                 | 存放要更新的文件             |
| public/index.txt          | 索引文件，也叫版本号列表文件 |
| public/index.internal.txt | 同上，但是用于支持灰度发布   |
| ignores.txt               | 文件忽略规则                 |

#### 2.计算文件差异

打包时，扫描工作空间目录的内容，和上个版本进行对比，算出文件差异，分别记录到五个列表里：

1. 删除的文件
2. 删除的目录
3. 覆盖的文件（新增和修改都视为覆盖）
4. 创建的目录
5. 移动的文件

在扫描文件修改时，会遇到各种情况，会分别记录成不同文件操作，具体的决策表如下

| 决策表           | 现在是目录                                               | 现在是文件                                       | 现在不存在了         |
| ---------------- | -------------------------------------------------------- | ------------------------------------------------ | -------------------- |
| 之前是目录       | 不做记录，而是进一步对比目录里面的内容                   | 旧目录记录为删除，并将新增文件的记录为覆盖       | 记录这个目录删除行为 |
| 之前是文件       | 旧文件记录为删除，并记录新增的目录下的全部文件内容为覆盖 | 先对比修改时间，再对比文件哈希，不同则记录为覆盖 | 记录这个文件删除行为 |
| 之前没有这个文件 | 记录新增的目录下的全部文件内容为覆盖                     | 记录这个新增的文件数据为覆盖                     | 什么也不做           |

其中移动文件的操作无法直接检测出来，但是可以通过检查一下新增文件列表（覆盖文件列表）和删除文件列表。如果发现这两个列表中有哈希值相同的文件存在，那么就可以认为这是一个文件移动操作。此时把这个文件从这俩列表里拿出来，然后插到文件移动列表中

所有这些文件修改操作会被记录下来，并发送到客户端，客户端收到后，会复现这些操作，这样就完成了文件同步

客户端复现时需要讲究严格顺序：删除旧文件 -> 覆盖文件 -> 移动文件 -> 更新文件 -> 删除目录

所有“覆盖的文件”除了有路径和哈希以外，打包时还得额外带上这个文件本身的二进制数据，这样客户端才可以进行解压覆盖。而其它文件操作则只需要有路径就够了，没有必要带着完整的文件数据

#### 3.更新包格式

所有更新包数据都会存储在public目录下的各个tar文件中。其中合并包可以容纳多个版本的数据，其它更新包只能容纳一个版本的数据

1. index.txt：索引文件，包含所有所有更新包的文件名和元数据偏移值
2. combined.tar：合并包，所有合并后的更新包内容都会放到这个文件里，可以容纳多个版本的数据。基本包只有在合并过一次之后才会出现
3. 1.0.tar：用户创建的1.0版本更新包，仅能容纳一个版本的数据
4. 1.1.tar：用户创建的1.1版本更新包，仅能容纳一个版本的数据
5. 还有更多用户创建的更新包

索引文件格式如下，是一个json文件

1. label代表更新包的版本号
2. file代表这个版本的数据在那个tar包里，因为合并包里可能会同时包含多个更新包的数据
3. offset代表元数据文件的偏移值
4. hash代表整个tar包的校验，防止用户手欠，乱改更新包里面的文件

合并包的文件名固定叫combine.tar，且永远在最前面

```
[
	{
		"label": "0.0.1",
		"file": "combined.tar",
		"offset": 2A3C,
		"hash": "23B87EA52C893"
	},
	{
		"label": "1.0.tar",
		"file": "1.0.tar",
		"offset": 7A9C,
		"hash": "23B87EA52C893"
	},
	{
		"label": "1.1.tar",
		"file": "1.1.tar",
		"offset": 2B3B,
		"hash": "23B87EA52C893"
	}
]
```

覆盖的文件的二进制数据放在tar包的开头，每个文件的偏移值记录在元数据中。元数据则放在文件末尾，元数据本身的偏移值记录在索引文件中，方便直接定位

更新包tar数据排布方式：`| a.txt | b.ogg | c.jar | 元数据 | `

- 普通包中会存放多个文件二进制数据，末尾的元数据文件只存放单个版本的元数据
- 合并包中会同时存放多个版本的二进制数据，同时元数据文件也会包含多个版本的元数据

元数据是一个json文件，包含这个更新包的所有信息，下面是普通包中元数据

```json
{
    "logs": "这是这个版本的更新记录文字示例", // 这个版本的更新日志
    "changes": [ // 记录所有文件修改操作
    	{
            "operation": "create-directory", // 创建一个目录
            "path": ".minecraft/mods"        // 要创建目录的路径
        }, {
            "operation": "update-file",      // 新增或者更新现有文件
            "path": "游玩指南.txt",           // 要写入的文件路径
            "hash": "82e09fc553b335ab_1306", // 文件校验值
            "length": 13761,                 // 文件长度
            "modified": 1705651134,          // 文件的修改时间
            "offset": 98724                  // 二进制数据在更新包中的偏移值
        }, {
            "operation": "delete-directory", // 删除一个目录
            "path": ".minecraft/logs"        // 要删除的目录的路径
        }, {
            "operation": "delete-file",      // 删除一个文件
            "path": ".minecraft/logs/1.log"  // 要删除的文件的路径
        }, {
            "operation": "move-file",        // 移动一个文件
            "from": ".minecraft/mods/a.jar", // 从哪里来
            "to": ".minecraft/mods/b.txt"    // 到哪里去
        }
    ]
}
```

如果是合并包中的元数据文件，则是一个json列表，包含多个版本的元数据

```json
[
    {
        "logs": "这是1.0版本的更新记录文字示例", // 这个版本的更新日志
        "changes": [ // 记录所有文件修改操作
            // 此处省略
        ]
    }, {
        "logs": "这是1.1版本的更新记录文字示例", // 这个版本的更新日志
        "changes": [ // 记录所有文件修改操作
            // 此处省略
        ]
    }
]
```

#### 4.版本打包

大致流程：先计算工作空间目录的修改情况，和上个版本进行对比，算出文件差异。然后将这些差异记录在一个新的更新包中

##### a.获取上个版本的状态

由于没有history目录，要得出上个版本的文件状态只能从过往的更新包中读取，模拟一个客户端，一步步计算推演出来

过程很简单，在内存先创建一个空的目录，然后按时间顺序，依次读取并复现所有更新包中的操作即可（从零开始依次安装了所有的更新包），复现完后，这个目录就是工作空间没有修改前的状态了，就可以和现有的文件进行对比了

##### b.创建更新包

更新包是个tar文件，写入时依次读取文件差异中的“覆盖的文件”列表里的文件，将这些文件数据写入到更新包里，一个挨着一个

在所有的文件修改列表中，只有“覆盖的文件”这个列表里的文件的内容需要写入到更新包里，删除文件或者删除目录，以及移动文件这些操作，仅仅有路径就够了，没有额外的数据要需要写到更新包里，所以这里仅保存了“覆盖的文件”这个列表

另外无论是工作空间目录下新增了一个全新的文件，还是对一个现有的文件进行修改了几个字节，都视为“覆盖的文件”操作，也就是直接记录整个文件数据，不会再像老版本那样去计算文件差异了，现在直接使用快照方式记录数据

在写入每个文件数据时，还要顺便记录这些文件的写入位置（偏移指针），后面会将这些偏移值写到元数据里以供后续读取更新包时定位用

最后一个要写到更新包里的文件是元数据文件，元数据文件格式参考上面

##### c.善后工作

这样更新包文件就创建完毕了，此时还有最后一个步骤，要将更新包的文件名追加到`public/index.internal.txt`  索引文件的末尾，这样客户端读取后，就知道多了一个新版本

不是所有服务器都支持“列目录操作”，所以将文件名单独存到一个索引文件里是很有必要的

##### d.内部测试

public目录下有两个`index.txt`索引文件，一个带`internal`，一个不带。带`internal`的文件后面代称为“内部文件”，不带的代称为“线上文件”

区分内部环境和线上环境主要是用于正式发布前测试用，新创建好的更新包不会出现在线上文件中，玩家并不知道刚创建了新版本，但是内部文件中会有这个新更新包的文件名。此时可以先进行内部测试，没问题后再同步文件内容，发布到线上

服主应该自备一个客户端用来测试，并填上带内部文件的链接，自己测试没问题了，再同步这两个文件的内容，让玩家可以下载

#### 5.版本合并











