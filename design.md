### 管理端的所有功能

1. 打包新版本
2. 合并新版本
3. 解压并测试现有的文件
4. 合并版本
5. 检查工作空间目录修改情况
6. 同步线上版本

### 管理端整体架构

1. 数据存储
2. 计算文件差异
3. 更新包格式
4. 版本打包
5. 版本合并
6. 基于TBF的流控

#### 1.数据存储

| 什么东西                     | 什么用途                   |
| ---------------------------- | -------------------------- |
| public                       | 存放更新包和索引文件       |
| workspace                    | 存放要更新的文件           |
| public/versions.txt          | 版本号列表文件             |
| public/versions.internal.txt | 同上，但是用于支持灰度发布 |
| ignores.txt                  | 文件忽略规则               |

#### 2.计算文件差异

打包时，扫描工作空间目录的内容，和上个版本进行对比，算出文件差异，分别记录到五个列表里：

1. 删除文件
2. 删除目录
3. 更新文件（新增和修改都视为更新）
4. 创建目录
5. 移动文件

在扫描文件修改时，会遇到各种情况，会分别记录成不同文件操作，具体的决策表如下

| 决策表           | 现在是目录                                         | 现在是文件                             | 现在不存在了         |
| ---------------- | -------------------------------------------------- | -------------------------------------- | -------------------- |
| 之前是目录       | 不做记录，而是进一步对比目录里面的内容             | 旧目录记录为删除，并记录新增文件的数据 | 记录这个目录删除行为 |
| 之前是文件       | 旧文件记录为删除，并记录新增的目录下的全部文件内容 | 先对比修改时间，再对比文件哈希         | 记录这个文件删除行为 |
| 之前没有这个文件 | 记录新增的目录下的全部文件内容                     | 记录这个新增的文件数据                 | 什么也不做           |

其中移动文件的操作无法直接检测出来，但是可以通过检查一下新增文件列表和删除文件列表。如果发现这两个列表中有哈希值相同的文件存在，那么就可以认为这是一个文件移动操作。此时把这个文件从这俩列表里拿出来，然后插到文件移动列表中

所有的文件修改操作会被记录下来，并发送到客户端，客户端会复现这些操作，这样就完成了文件同步

客户端复现时需要讲究严格顺序：删除旧文件 -> 创建新文件 -> 移动文件 -> 更新文件 -> 删除目录

#### 3.更新包格式

更新包使用tar格式存储，tar没有文件头，很适合http环境的随机读取

所有要更新的文件的二进制数据会存储在更新包文件的不同位置上，互不重叠，靠指针偏移读取对应的文件数据

更新包数据排布方式：`| 地址文件 | a.txt | b.ogg | c.jar | 元数据 | `

地址文件放在文件开头，里面存有元数据文件的偏移值，内容是一个字符串`2A3C`，表示在文件的2A3C处就是元数据的起始地址。元数据地址文件的长度不能超过tar块的长度，也就是512，否则后面所有的偏移指针都会失效

实际的元数据存放在末尾，是一个json文件，包含这个更新包的所有信息

```json
{
    "logs": "这是这个版本的更新记录文字示例", // 这个版本的更新日志
    "changes": [ // 记录所有文件修改操作
    	{
            "operation": "create-directory", // 创建一个目录
            "path": ".minecraft/mods"        // 要创建目录的路径
        }, {
            "operation": "update-file",      // 新增或者更新现有文件
            "path": "游玩指南.txt",           // 要写入的文件路径
            "hash": "82e09fc553b335ab_1306", // 文件校验值
            "length": 13761,                 // 文件长度
            "modified": 1705651134,          // 文件的修改时间
            "offset": 98724                  // 二进制数据在更新包中的偏移值
        }, {
            "operation": "delete-directory", // 删除一个目录
            "path": ".minecraft/logs"        // 要删除的目录的路径
        }, {
            "operation": "delete-file",      // 删除一个文件
            "path": ".minecraft/logs/1.log"  // 要删除的文件的路径
        }, {
            "operation": "move-file",        // 移动一个文件
            "from": ".minecraft/mods/a.jar", // 从哪里来
            "to": ".minecraft/mods/b.txt"    // 到哪里去
        }
    ]
}
```

#### 4.版本打包

大致流程：先计算工作空间目录的修改情况，和上个版本进行对比，算出文件差异。然后将这些差异记录在一个新的更新包中

##### a.获取上个版本的状态

由于没有history目录，要得出上个版本的文件状态只能从过往的更新包中读取，模拟一个客户端，一步步计算推演出来

过程很简单，在内存先创建一个空的目录，然后按时间顺序，依次读取并复现所有更新包中的操作即可（从零开始依次安装了所有的更新包），复现完后，这个目录就是工作空间没有修改前的状态了，就可以和现有的文件进行对比了

##### b.创建更新包

更新包是个tar文件，写入时依次读取文件差异中的“更新文件”列表里的文件，将这些文件数据复制到更新包里，一个挨着一个

在所有的文件修改列表中，只有“更新文件”这个列表里的文件的内容需要写入到更新包里，删除文件或者删除目录，以及移动文件这些操作，仅仅有路径就够了，没有额外的数据要需要写到更新包里，所以这里仅保存了“更新文件”这个列表

另外无论是工作空间目录下新增了一个全新的文件，还是对一个现有的文件进行修改了几个字节，都视为“更新文件”操作，也就是直接记录整个文件数据，不会再像老版本那样去计算文件差异了，现在直接使用快照方式记录数据

在写入每个文件数据时，还要顺便记录这些文件的写入位置（偏移指针），后面会将这些偏移值写到元数据里以供后续读取更新包时定位用

最后一个要写到更新包里的文件是元数据文件，元数据文件格式参考上面

##### c.善后工作

这样更新包文件就创建完毕了，此时还有最后一个步骤，要将更新包的文件名追加到`public/versions.internal.txt`文件末尾，这样客户端读取后，就知道多了一个新版本

不是所有服务器都支持“列目录操作”，所以将文件名单独存到一个文件里是很有必要的

##### d.内部测试

public目录下有两个`versions.txt`文件，一个带`internal`，一个不带。带`internal`的文件后面代称为“内部文件”，不带的代称为“线上文件”

区分内部环境和线上环境主要是用于正式发布前测试用，新创建好的更新包不会出现在线上文件中，玩家并不知道刚创建了新版本，但是内部文件中会有这个新更新包的文件名。此时可以先进行内部测试，没问题后再同步文件内容，发布到线上

服主应该自备一个客户端用来测试，并填上带内部文件的链接，自己测试没问题了，再同步这两个文件的内容，让玩家可以下载

#### 5.版本合并











